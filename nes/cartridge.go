package nes

import (
	"encoding/binary"
	"errors"
	"io"
	"os"
)

// MirrorType determines a cartridge's nametable mirroring arrangement.
type MirrorType int

const (
	horizontal MirrorType = iota
	vertical
	singleLow
	singleHigh
	fourScreen
)

// A Cartridge represents a physical game cartridge.
type Cartridge struct {
	Mirror MirrorType
	Mapper Mapper
	PRG    [][]byte // [bank][byte], 16k banks.
	CHR    [][]byte // [bank][byte], 8k banks.
	SRAM   [][]byte // [bank][byte], 8k banks.
}

// LoadCartridge opens and reads an iNES format ROM file.
//
//    cart, err := LoadCartridge("test.rom")
func LoadCartridge(filename string) (*Cartridge, error) {
	file, err := os.Open(filename)

	if err != nil {
		return nil, err
	}

	defer file.Close()

	cart, err := ReadCartridge(file)

	return cart, err
}

// NewCartridge constructs an empty Cartridge with the given memory bank sizes.
//
// PRG banks are 16k bytes, CHR and SRAM banks are both 8k bytes. No mapper is
// set.
func NewCartridge(numPRGBanks int, numCHRBanks int, numSRAMBanks int) *Cartridge {
	var c *Cartridge = &Cartridge{}

	if numCHRBanks == 0 {
		numCHRBanks = 1
	}

	if numSRAMBanks == 0 {
		numSRAMBanks = 1
	}

	c.PRG = make([][]byte, numPRGBanks)
	c.CHR = make([][]byte, numCHRBanks)
	c.SRAM = make([][]byte, numSRAMBanks)

	for i := range c.PRG {
		c.PRG[i] = make([]byte, 16384)
	}

	for i := range c.CHR {
		c.CHR[i] = make([]byte, 8192)
	}

	for i := range c.SRAM {
		c.SRAM[i] = make([]byte, 8192)
	}

	return c
}

// ReadCartridge reads an iNES v1.0 ROM file from file.
//
// http://wiki.nesdev.com/w/index.php/INES
func ReadCartridge(file io.Reader) (*Cartridge, error) {
	type iNESHeader struct {
		Magic        [3]byte
		Format       byte
		NumPRGBanks  byte
		NumCHRBanks  byte
		Control1     byte
		Control2     byte
		NumSRAMBanks byte
		_            [7]byte
	}

	var header iNESHeader

	err := binary.Read(file, binary.LittleEndian, &header)

	if err != nil {
		return nil, errors.New("error reading header")
	} else if header.Magic != [3]byte{'N', 'E', 'S'} {
		return nil, errors.New("not an iNES file")
	}

	if header.Format != 0x1a {
		return nil, errors.New("unsupported iNES format type")
	}

	if header.NumSRAMBanks == 0 {
		header.NumSRAMBanks = 1
	}

	cart := NewCartridge(int(header.NumPRGBanks), int(header.NumCHRBanks), int(header.NumSRAMBanks))

	if header.Control1&0x02 != 0 {
		cart.Mirror = fourScreen
	} else if header.Control1&0x1 != 0 {
		cart.Mirror = vertical
	} else {
		cart.Mirror = horizontal
	}

	hasTrainer := header.Control1&0x04 != 0
	if hasTrainer {
		buf := make([]byte, 512)
		if _, err := io.ReadFull(file, buf); err != nil {
			return nil, err
		}
	}
	
	numCHRBanks := int(header.NumCHRBanks)
	for i := range cart.PRG {
		n, err := io.ReadFull(file, cart.PRG[i])

		if (err == io.EOF || err == io.ErrUnexpectedEOF) &&
				n == len(cart.PRG[i]) && numCHRBanks == 0 {
			break
		} else if err != nil {
			return nil, err
		}
	}

	if numCHRBanks > 0 {
		for i := range cart.CHR {
			_, err = io.ReadFull(file, cart.CHR[i])

			if err == io.EOF || err == io.ErrUnexpectedEOF {
				break
			} else if err != nil {
				return nil, err
			}
		}
	}

	mapper_id := int((header.Control1 >> 4) | (header.Control2 & 0xf0))

	// For nestest.nes.
	if mapper_id == 171 {
		mapper_id = 0
	}

	cart.Mapper, err = NewMapper(mapper_id, cart)
	if err != nil {
		return nil, err
	}

	return cart, nil
}

// Read reads a byte from the cartridge.
//
// address is the location to read from. Set isPPU to read from the PPU address
// space instead of the CPU address space.
func (cart *Cartridge) Read(address uint16, isPPU bool) byte {
	return cart.Mapper.Read(address, isPPU)
}

// Write writes a byte to the cartridge.
//
// address is the location to write to. Set isPPU to write to the PPU address
// space instead of the CPU address space.
func (cart *Cartridge) Write(address uint16, value byte, isPPU bool) {
	cart.Mapper.Write(address, value, isPPU)
}

// IRQ returns true if the Cartridge has any outstanding interrupt requests
// (IRQs). IRQs are typically generated by Mappers performing scanline counting.
//
// Any outstanding IRQs are reset.
func (cart *Cartridge) IRQ() bool {
	return cart.Mapper.IRQ()
}

// NextScanline is called around tick 260 on visible/prerender scanlines to
// indicate the scanline will soon increment. This is used by games performing
// split screen effects.
//
// http://wiki.nesdev.com/w/index.php/MMC3 .
func (cart *Cartridge) NextScanline() {
	cart.Mapper.NextScanline()
}
